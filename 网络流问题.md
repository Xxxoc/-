# 网络流问题

假设这是一个水流网络系统，想从s点将水输送到t点，有向边代表管道，其权值表示的含义是该管道的最大容量，水通过该管道的流量不能大于容量，否则管道会破裂，除了s和t以外结点称为中间结点，每一个中间结点都满足：流入该中间结点的流量等于流出的流量，中间结点只是转换的作用，没有存储的功能。问：从s到t能输送最多多少的水流量？


## 可使用算法

## 1.[Flow](https://so.csdn.net/so/search?q=Flow&spm=1001.2101.3001.7020) Networks

其流量就是一种抽象的实体：在源结点产生，通过边传输，并在终端结点被吸收，我们将这样一种Flow Networks建模为一个 有向图G=（V，E），具有如下特点：

1. 边e上的非负数值ce代表的是容量
2. V中只有一个源结点s
3. V中只有一个终端结点t
4. V中除了s和t的结点叫作中间结点。

我们对该Flow Networks进行了三点假设：

1. s没有入边，t没有出边
2. 每个结点都至少和一条边关联
3. 所有的容量值都用整数来表示

```python
import os
import numpy as np
import cv2
from glob import glob
from PIL import Image
import imageio

def cal_for_frames(video_path):  #读取图片并计算光流，染后保存下来
    frames = glob(os.path.join(video_path, '*.jpg'))
    frames.sort()

    flow = []
    prev = imageio.imread(frames[0])  #是uint型的Array
    prev = cv2.cvtColor(prev, cv2.COLOR_BGR2GRAY)
    for i, frame_curr in enumerate(frames[1:]):
        curr = imageio.imread(frame_curr)
        curr = cv2.cvtColor(curr, cv2.COLOR_BGR2GRAY)
        tmp_flow = compute_TVL1(prev, curr)
        flow.append(tmp_flow)
        prev = curr
        print('complete:' + str(i))

    return flow


def compute_TVL1(prev, curr, bound=15):
    """Compute the TV-L1 optical flow."""
    TVL1 = cv2.createOptFlow_DualTVL1()  ## 得到  <DualTVL1OpticalFlow 0x7fe8247ce130>
    flow = TVL1.calc(prev, curr, None)  ##得到两通道的流
    print(flow.dtype)
    return flow
def ToImg(raw_flow,bound):
    '''
    this function scale the input pixels to 0-255 with bi-bound

    :param raw_flow: input raw pixel value (not in 0-255)
    :param bound: upper and lower bound (-bound, bound)
    :return: pixel value scale from 0 to 255
    '''
    flow=raw_flow
    flow[flow>bound]=bound
    flow[flow<-bound]=-bound
    flow-=-bound
    flow*=(255/float(2*bound))
    flow=flow.astype(np.uint8)
    return flow

def save_flow(video_flows, flow_path):
    for i, flow in enumerate(video_flows):
        flow_x = ToImg(flow[..., 0], 15)
        flow_y = ToImg(flow[..., 1], 15)
        flow_x_img = Image.fromarray(flow_x)
        flow_y_img = Image.fromarray(flow_y)
        imageio.imwrite(os.path.join(flow_path,'flow_x_{:05d}.jpg'.format(i)),
                    flow_x_img)
        imageio.imwrite(os.path.join(flow_path,'flow_y_{:05d}.jpg'.format(i)),
                    flow_y_img)
def extract_flow(video_path, flow_path):
    flow = cal_for_frames(video_path)
    save_flow(flow, flow_path)
    print('complete:' + flow_path)
    return
if __name__ == '__main__':
    video_paths = "/home/hongyuan/data/test_data/OTB50/Deer/img"  #要提取视频帧的路径，最简单的
    flow_paths = "/home/hongyuan/projects/wenmei/flow/"  #保存流的路径
    extract_flow(video_paths, flow_paths)

```



## 2.Defining Flow

定义s-t flow为函数f：把每条边e映射到一个正实数，f(e)的值表示的是e这条边上实际承载的流量。一个f flow必须满足以下两个特性：

1. 容量约束：对于E中的每一个e，有0<=f(e)<=ce
2. 平衡约束：对于所有的中间结点有

![在这里插入图片描述](https://img-blog.csdnimg.cn/a3ea6ec4dab645169dd91221ee94634d.png)

1. 前者代表所有进入结点v的流量，后者代表从v流出的所有流量

一条边上的流量不能超过其容量，一个flow f的值，表示为v(f)，其含义是在源结点产生的流量：

![在这里插入图片描述](https://img-blog.csdnimg.cn/f5bee9e326c145b5a8255a3bc2565581.png)