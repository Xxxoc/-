#### 整数线性规划

*在某些线性规划的问题中，变量只有取整数值才有意义，这时约束条件中还需添上变量取整数值的限制。这就是整数线性规划，一般形式略。*

*若其中只有部分变量要求取整数，则称为混合整数规划*。

以下初步介绍两个基本方法：

##### 1.割平面法

*基本思想：不考虑整数性要求，用单纯形法求出所给问题的最优解，若其中每个变量恰好都取整数值，则它正好是所求的解；否则，就设法把这个最优解的极点，连同它的一个领域，从可行解集合中"切除"，但保留其中全部格点(这样的切除，并不影响问题的结果)对可行解剩下部分重复上述步骤，范围逐渐缩小，直到找到最优解为止。这里的关键时如何实现上述的"切除"。事实上，这将通过一个附加的约束条件(割平面)来实现，故称为割平面法。*

**详见p57例题**（我反正没看懂）

##### 2.分支定界法

*分支定界法可适用于纯整数规划以及混合整数规划*

<u>*详细解法请看**p60***</u>

**解题步骤：**
*题目一般给予一个要求最大/小值的线性方程式，以及多个限定条件R*

*第一步：忽略限定条件R中的未知数为整数的条件，求出对应的最优解*

*第二步：已知在第一步求出的最优解不为整数，又因为未知数为整数，因此对多个未知数分支定界讨论，限定条件大于等于取整加一的数、小于等于取整的数。若未知数为2，则可以得到四条方程。*

*第三步：带入得到的未知数，求得线性方程的解，对比要求的为最大还是最小解，划出最优解的方程（其中可能等到与原限定条件相互矛盾的方程，舍去即可）*

*第四步：继续第二步，直到得到未知数符合限定条件为整数，且最优解最大或最小时，求解完成。*

    function [intx,intf] = DividePlane(A,c,b,baseVector)

% 调用格式：[intx,intf] = DividePlane(A,c,b,baseVector)  

% 其中，A:约束矩阵  

%        c:目标函数系数向量

%        b:约束右端向量

%        baseVector:初始基向量

%        intx：目标函数取最小值时的自变量值

%        intf：目标函数的最小值

% 在命令窗口输入下参数  

%  A=[0.01 0.01 0.01 0.03 0.03 0.03 1 0 0 0;  %约束条件 系数

%       0.02 0 0 0.05 0 0 0 1 0 0;

%       0 0.02 0 0 0.05 0 0 0 1 0;

%       0 0 0.03 0 0 0.08 0 0 0 1];

% %  c=[-20 -14 -16 36 -32 -30];   %最大值取反后，最小值函数系数

%  b=[850 700 100 900];            %约束条件 右端值

%  [intx,intf]=DividePlane(A,c,b,[7 8 9 10]);  % X7 X8 X9 X10

sz = size(A);

nVia = sz(2);%获取有多少决策变量

n = sz(1);%获取有多少约束条件

xx = 1 : nVia;

if length(baseVector) ~= n

    disp('基向量的个数要与约束矩阵的行数相等！');
    
    mx = NaN;
    
    mf = NaN； 
    
    return;
  end

M = 0;

sigma = -[transpose(c) zeros(1,(nVia - length(c)))];

xb = b;


%首先单纯形边求出最优解
while 1
    [maxs,ind] = max(sigma);
    %--------------用单纯形法求最优解-------------
    if maxs <= 0 %当校验数小于0时，球的最优解
        vr = find(c~=0,1,'last');
        for l = 1 : vr
            ele = find(baseVector == l,1);
            if (isempty(ele))
                mx(l) = 0;
            else
                mx(l) = xb(ele);
            end
        end
        if max(abs(round(mx) - mx)) < 1.0e-7  %判断最优解是否为整数解 ，如果是整数解
            intx = mx;
            intf = mx*c;
        else %如果最优解不是整数解时，构建切割方法
            sz = size(A);
            sr = sz(1);
            sc = sz(2);
            [max_x,index_x] = max(abs(round(mx) - mx));
            [isB,num] = find(index_x == baseVector);
            fi = xb(num) - floor(xb(num));
            for i = 1 : (index_x - 1)
                Atmp(1,i) = A(num,i) - floor(A(num,i));
            end
            for i = (index_x + 1) : sc
                Atmp(1,i) = A(num,i) - floor(A(num,i));
            end
            Atemp(1,index_x) = 0; %构建对偶单纯形法的初始表格
            A = [A zeros(sr,1):-Atmp(1,:) 1];
            xb = [xb:-fi];
            baseVector = [baseVetor sc+1];
            sigma = [sigma 0];
            
            %----------对偶单纯形法的迭代过程--------------
            while 1
                %-----------------------------------------
                if xb > 0   %判断如果右端向量大于0，求得最优解
                  if max(abs(round(xb)-xb)) < 1.0e-7  %如果用对偶单纯形法求得了整数解，则返回最优整数解
                      vr = find(c~=0,1,'last');
                      for l = 1 : vr
                          ele = find(baseVector == l,1);
                          if (isempty(ele))
                              mx_1(1) = 0;
                          else
                              mx_1(1) = xb(ele);
                          end
                      end
                      intx = mx_1;
                      intf = mx_1*c;
                      return;
                  else %如果对偶单纯形法求得的最优解不是整数解，切割方程
                      sz = size(A);
                      ar = sz(1);
                      ac = sz(2);
                      [max_x,index_x] = max(abs(round(mx_1) - mx_1));
                      [isB,num] = find(index_x == baseVector);
                      fi = xb(num) - floor(xb(num));
                      for i = 1 : (index_x - 1)
                          Atemp(1,i) = A(num,i) - floor(A(num,i));
                      end
                      for i = (index_x+1):sc
                          Atemp(1,i) = A(num,i) - floor(A(num,i));
                      end
                      Atemp(1,index_x) = 0;%
                      A = [A zeros(sr,1);-Atemp(1,:) 1];
                      xb = [xb;-fi];
                      baseVector = [baseVector sc+1];
                      sigma = [sigma 0];
                      continue;
                  end
                else %如果右端向量不全大于0，则进行对偶单纯形法的换基变量过程
                    minb_1 = inf;
                    chagB_1 = inf;
                    sA = size(A);
                    [br,idb] = min(xb);
                    for j = 1 : sA(2)
                        if A(idb,j) < 0
                            bn = sigma(j)/A(idb,j);
                            if bn < minb_1
                                minb_1 = bn;
                                chagB_1 = j;
                                
                            end
                        end
                    end
                    sigma = sigma - A(idb,:)*minb_1;
                    xb(idb) = xb(idb)/A(idb,chagB_1);
                    A(idb,:) = A(idb,:)/A(idb,chagB_1);
                    for i = 1:sA(1)
                        if i~= idb
                            xb(i) = xb(i)-A(i,chagB_1)*xb(idb);
                            A(i,:) = A(i,:) - A(i,chagB_1)*A(idb,:);
                        end
                    end
                    baseVector(idb) = chagB_1;
                end
                
            end
            
        end      %迭代过程
%     end
    
else %如果校验数有不小于0的，则进行单纯形算法迭代过程
        minb = inf;
        chagB = inf;
        for j = 1:n
            if A(j,ind) > 0
                bz = xb(j)/A(j,ind);
                if bz < minb
                    minb = bz;
                    chagB = j;
                end
            end
            
        end
        sigma = sigma - A(chagB,:)*maxs/A(chagB,ind);
        xb(chagB) = xb(chagB)/A(chagB,ind);
        A(chagB,:) = A(chagB,:)/A(chagB,ind);
        for i = 1 : n
            if i~=chagB
                xb(i) = xb(i) - A(i,ind)*xb(chagB);
                A(i,:) = A(i,:) - A(i,ind)*A(chagB,:);
                
            end
        end
        baseVector(chagB) = ind;
end

M = M + 1;

if (M == 1000000)

    disp('找不到最优解！');
    
    mx = NaN;
    
    minf = NaN;
    
    return;
    
end

        
end
